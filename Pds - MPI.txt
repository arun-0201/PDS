GroupCommunication

#include <stdio.h>
#include <stdlib.h>
#include "mpi.h"

int main(int argc, char** argv) {
    int rank, size, i;
    int bcast_data, scatter_val, local_val, sum_result;
    int *send_array = NULL, *gather_array = NULL;

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    if (rank == 0) {
        bcast_data = 100;
        printf("P0 broadcasting: %d\n", bcast_data);
    }
    MPI_Bcast(&bcast_data, 1, MPI_INT, 0, MPI_COMM_WORLD);
    printf("P%d got broadcast: %d\n", rank, bcast_data);

    if (rank == 0) {
        send_array = malloc(size * sizeof(int));
        for (i = 0; i < size; i++) send_array[i] = (i + 1) * 10;
        printf("\nP0 scattering: ");
        for (i = 0; i < size; i++) printf("%d ", send_array[i]);
        printf("\n");
    }
    MPI_Scatter(send_array, 1, MPI_INT, &scatter_val, 1, MPI_INT, 0, MPI_COMM_WORLD);
    printf("P%d got scattered: %d\n", rank, scatter_val);
    free(send_array);

    local_val = (rank + 1) * 5;
    printf("\nP%d local value: %d\n", rank, local_val);
    MPI_Reduce(&local_val, &sum_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);
    if (rank == 0) printf("P0 reduce sum: %d\n", sum_result);

    if (rank == 0) gather_array = malloc(size * sizeof(int));
    int gather_val = rank * 2;
    MPI_Gather(&gather_val, 1, MPI_INT, gather_array, 1, MPI_INT, 0, MPI_COMM_WORLD);
    if (rank == 0) {
        printf("\nP0 gathered: ");
        for (i = 0; i < size; i++) printf("%d ", gather_array[i]);
        printf("\n");
        free(gather_array);
    }

    MPI_Finalize();
    return 0;
}


-----------------------------------------------------------------------------------------

Chat Server using send & recv
#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv) {
  const int PING_PONG_LIMIT = 10;

  MPI_Init(NULL, NULL);
  int world_rank;
  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);
  int world_size;
  MPI_Comm_size(MPI_COMM_WORLD, &world_size);
  if (world_size != 2) {
    fprintf(stderr, "World size must be two for %s\n", argv[0]);
    MPI_Abort(MPI_COMM_WORLD, 1);
  }

  int ping_pong_count = 0;
  int partner_rank = (world_rank + 1) % 2;
  while (ping_pong_count < PING_PONG_LIMIT) {
    if (world_rank == ping_pong_count % 2) {
      ping_pong_count++;
      MPI_Send(&ping_pong_count, 1, MPI_INT, partner_rank, 0, MPI_COMM_WORLD);
      printf("%d sent and incremented ping_pong_count %d to %d\n",
             world_rank, ping_pong_count, partner_rank);
    } else {
      MPI_Recv(&ping_pong_count, 1, MPI_INT, partner_rank, 0, MPI_COMM_WORLD,
               MPI_STATUS_IGNORE);
      printf("%d received ping_pong_count %d from %d\n",
             world_rank, ping_pong_count, partner_rank);
    }
  }
  MPI_Finalize();
}

Execution :
mpicc -o mpi filename.c
mpirun -np 2 mpi

-----------------------------------------------------------------------------------------

Mutual exclusion

#include <stdio.h>
#include <mpi.h>
int main(int argc, char **argv)
{
	int size, rank;
	MPI_Init(&argc, &argv);
	MPI_Comm_size(MPI_COMM_WORLD, &size);
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);
	int shared = 0;
	if (rank == 0)
	{
		int queue[10];
		for (int j = 0; j < 10; j++)
			queue[j] = 0;
		int front = 0;
		int rear = -1;
		int count = 0;
		int lock = 0;
		int process;
		MPI_Status st;
		while (1)
		{
			MPI_Recv(&process, 1, MPI_INT, MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &st); 
			if (st.MPI_SOURCE == 0)
				break;
			printf("Queue has ");
			for (int j = front; j < 6; j++)
			{
				if (queue[j] == 0)
					break;
				printf("%d ", queue[j]);
			}
			printf("\n");
			if (st.MPI_TAG == 3)
			{
				shared = process;
				int send = queue[front++];
				count--;
				printf("Process %d changed value is %d\n", st.MPI_SOURCE, shared);
				if (send == 0)
					break;
				printf("Process %d acquired shared resource\n", send);
				MPI_Send(&shared, 1, MPI_INT, send, 2, MPI_COMM_WORLD);
			}
			if (st.MPI_TAG == 1)
			{
				if (lock == 0 && count == 0)
				{
					lock = 1;
					printf("Process %d acquired shared resource\n", process);
					MPI_Send(&shared, 1, MPI_INT, process, 2, MPI_COMM_WORLD);
				}
				else
				{
					queue[++rear] = process;
					count++;
				}
			}
		}
	}
	else
	{
		MPI_Send(&rank, 1, MPI_INT, 0, 1, MPI_COMM_WORLD);
		MPI_Status st;
		int recv;
		MPI_Recv(&shared, 1, MPI_INT, 0, 2, MPI_COMM_WORLD, &st);
		if (st.MPI_TAG == 2)
		{
			int before = shared;
			shared++;
			printf("Process %d, Before altering %d; After altering %d\n", rank, before,  shared);
			MPI_Send(&shared, 1, MPI_INT, 0, 3, MPI_COMM_WORLD);
		}
	}
	MPI_Finalize();
}
>> mpicc −o mpi mutualexclusion.c // if it shows error for "For loop initial execution " then >   mpicc -std=c99 -o mpi mutualExclusion2.c

>> mpirun −np 4 mpi
Sample output:

-----------------------------------------------------------------------------------------

Berkeley

#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(int argc, char** argv) {
    MPI_Init(&argc, &argv);

    int rank, size;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    srand(time(NULL) + rank);  
    double clock_offset = ((double)rand() / RAND_MAX) * 20.0 - 10.0;
    double local_time = MPI_Wtime() + clock_offset;

    if (rank == 0) {
        printf("Before synchronization:\n");
    }
    MPI_Barrier(MPI_COMM_WORLD); 
    printf("Process %d local time: %.2f %.2f\n", rank, local_time,local_time-clock_offset);
    MPI_Barrier(MPI_COMM_WORLD);


    double* all_times = NULL;
    if (rank == 0) {
        all_times = (double*)malloc(size * sizeof(double));
    }
    MPI_Gather(&local_time, 1, MPI_DOUBLE, all_times, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);

    double adjustment = 0.0;
    int i;
    if (rank == 0) {
  
        double sum = 0.0;
        for (i = 0; i < size; i++) {
            sum += all_times[i];
        }
        double average = sum / size;


        double* adjustments = (double*)malloc(size * sizeof(double));
        for (i = 0; i < size; i++) {
            adjustments[i] = average - all_times[i];
        }


        MPI_Scatter(adjustments, 1, MPI_DOUBLE, &adjustment, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);

        free(adjustments);
        free(all_times);
    } else {
        MPI_Scatter(NULL, 1, MPI_DOUBLE, &adjustment, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
    }

    local_time += adjustment;

    if (rank == 0) {
        printf("\nAfter synchronization:\n");
    }
    MPI_Barrier(MPI_COMM_WORLD);
    printf("Process %d adjusted time: %.2f (adjustment: %.2f)\n", rank, local_time, adjustment);
    MPI_Barrier(MPI_COMM_WORLD);

    MPI_Finalize();
    return 0;
}


-----------------------------------------------------------------------------------------

Byzantine faulty nodes

#include<stdio.h>
#include<mpi.h>
void main(int argc,char* argv[]){
int rank,size,i,j,r,k,count,faulty=0,majorityValue;
MPI_Init(&argc,&argv);
MPI_Comm_size(MPI_COMM_WORLD,&size);
MPI_Comm_rank(MPI_COMM_WORLD,&rank);
MPI_Status st;
if(rank==2||rank==5)
faulty=1;
if(faulty==1)
printf("i am rank %d Faulty..find me  \n",rank);
int recv[size];
if(faulty!=1){
        for(i=0;i<size;i++){
                if(i!=rank){
                        MPI_Send(&rank,1,MPI_INT,i,101,MPI_COMM_WORLD);
                }
        }
        for(i=0;i<size;i++){
                if(i==rank)
                        recv[i]=rank;
                else{
                        MPI_Recv(&recv[i],1,MPI_INT,i,101,MPI_COMM_WORLD,&st);
                }
        }
}
else if(faulty==1){
        for(i=0;i<size;i++){
                if(i!=rank){
                        r=(rand()+r*r)%100;
                        MPI_Send(&r,1,MPI_INT,i,101,MPI_COMM_WORLD);
                }
        }
        for(i=0;i<size;i++){ 
                if(i==rank)
                        recv[i]=rank;
                else{
                        MPI_Recv(&recv[i],1,MPI_INT,i,101,MPI_COMM_WORLD,&st);
                }
        }
        for(i=0;i<size;i++)
                        recv[i]=(rand()+r*r)%100;
}

for(i=0;i<size;i++)
        if(i!=rank)
                MPI_Send(recv,size,MPI_INT,i,201,MPI_COMM_WORLD);
int vect[size][size];
for(i=0;i<size-1;i++)
                MPI_Recv(vect[i],size,MPI_INT,MPI_ANY_SOURCE,201,MPI_COMM_WORLD,&st);
for(i=0;i<size;i++){
        for(j=0;j<size-1;j++){
                count=0;
                majorityValue=vect[j][i];
                for(k=0;k<size-1;k++){
                        if(vect[k][i]==majorityValue)
                                count++;
                        else
                                count--;
                }
                if(count>0){
                        break;
                }
        }
        if(j==size-1)
                printf("%d says %d is Faulty\n",rank,i);
}
MPI_Finalize();
}
mpicc -o mpi filename.c
mpirun -np 6 mpi


-----------------------------------------------------------------------------------------

Leader election

#include <stdlib.h>
#include <stdio.h>
#include "mpi.h"
void main(int argc, char *argv[])
{
	MPI_Init(&argc, &argv);
	int rank, size, recv, uid, next, prev, round = 1;
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);
	MPI_Comm_size(MPI_COMM_WORLD, &size);
	MPI_Status st;
	uid = (rand() * (rank + 1) * size) % 100;
	if (uid < 0)
	uid = uid + 100;
	printf("HI! I am rank %d uid %d\n", rank, uid);
	next = (rank == size - 1 ? 0 : rank + 1);
	prev = (rank == 0 ? size - 1 : rank - 1);
	MPI_Send(&uid, 1, MPI_INT, next, round, MPI_COMM_WORLD);
	while (1)
	{

		MPI_Recv(&recv, 1, MPI_INT, prev, MPI_ANY_TAG, MPI_COMM_WORLD, &st);
		if (st.MPI_TAG == 201)
		{
			MPI_Send(&recv, 1, MPI_INT, next, 201, MPI_COMM_WORLD);
			break;
		}
		else
		{
			round = st.MPI_TAG;
			printf("Round %d:My rank %d recieved %d\n", round, rank, recv);
			if (recv == uid)
			{
				printf("I am the leader...Rank %d uid:%d round %d \n", rank, uid, round);
				MPI_Send(&rank, 1, MPI_INT, next, 201, MPI_COMM_WORLD);
				break;
			}
			if (recv > uid)
			{
				MPI_Send(&recv, 1, MPI_INT, next, round + 1, MPI_COMM_WORLD);
			}
		}
	}
	MPI_Finalize();
}